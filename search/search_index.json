{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Gate Operator","text":"<p>The Gate Operator solves a simple problem : orchestration among declarative kubernetes workloads.</p>"},{"location":"#why","title":"Why","text":"<p>Even though eventual consistency is a core principle of Kubernetes philosophy, it is not always achievable in a purely declarative way.</p> <ul> <li>One pod may start with default credentials before the said credentials could be retrieved. Leading to a soft lock of the pod.</li> <li>Another workload may create a LoadBalancer service before the load balancer controller was deployed. Leading to the usage of legacy controller and misconfiguration (Hello, EKS!)</li> </ul> <p>Why is eventual consistency not always achievable is open to discussion. But, it is here and we need to deal with it.</p>"},{"location":"#solution","title":"Solution","text":"<p>To solve this issue, tools exists. ArgoCd, per example, provide SyncWaves and Hooks. However, it is only applicable on the application scope or, more recently, on the ApplicationSet scope. It's a partial solution. </p> <p>These limitations make difficult to orchestrate larger workloads spread across multiple charts, applications, etc.</p> <p>Enters Gate Operator with a simple yet powerful concept to synergize with deployment tools like ArgoCD</p>"},{"location":"#concept","title":"Concept","text":"<p>A Gate is a resource that have two possible state: opened or closed.</p> <p>It changes state when its logical expression is validated (then become opened) or invalidated (the become closed).</p> <p>It has a logical expression about resources in the cluster being in a certain way.</p> <p>Per example:</p> <ul> <li>A gate may wait for a specific Deployment to be Available</li> <li>Or to wait for a ConfigMap to be created</li> <li>Or for another gate to be Opened (or Closed)</li> </ul> <pre><code>flowchart LR\n    classDef wave1 fill:#FDE7FE,stroke:#333,stroke-width:3px;\n    classDef wave2 fill:#FDE7FE,stroke:#333,stroke-width:3px;\n    classDef wave3 fill:#F9BBFC,stroke:#333,stroke-width:3px;\n    classDef wave4 fill:#F48FFA,stroke:#333,stroke-width:3px;\n    classDef wave5 fill:#F063F8,stroke:#333,stroke-width:3px;\n\n    subgraph deploy-a [Deployment A]\n        direction LR\n        deploy-a-res1[Deployment]\n        deploy-a-res2[Secret]\n        deploy-a-res3[Resources...]\n        deploy-a-gate-out((\"Gate\"))\n        deploy-a-gate-out --&gt; deploy-a-res1 &amp; deploy-a-res2 &amp; deploy-a-res3\n\n        class deploy-a-res1 wave1;\n        class deploy-a-res2 wave1;\n        class deploy-a-res3 wave1;\n        class deploy-a-gate-out wave1;\n    end\n\n    subgraph deploy-b [Deployment B]\n        direction LR\n        deploy-b-res1[Deployment]\n        deploy-b-res2[Secret]\n        deploy-b-res3[Resources...]\n        deploy-b-gate-out((\"Gate\"))\n        deploy-b-gate-out --&gt; deploy-b-res1 &amp; deploy-b-res2 &amp; deploy-b-res3\n\n        class deploy-b-res1 wave2;\n        class deploy-b-res2 wave2;\n        class deploy-b-res3 wave2;\n        class deploy-b-gate-out wave2;\n    end\n\n    subgraph deploy-c [Deployment C]\n        direction LR\n        deploy-c-gate-in((\"Gate\"))\n        deploy-c-res1[Deployment 1]\n        deploy-c-res2[Deployment 2]\n        deploy-c-gate-internal((\"Gate\"))\n        deploy-c-res3[Deployment 3]\n        deploy-c-res4[Standalone&lt;br/&gt;Deployment]\n        deploy-c-gate-out((\"Gate\"))\n        deploy-c-gate-in --&gt; deploy-b-gate-out\n        deploy-c-gate-in ----&gt; deploy-a-gate-out\n        deploy-c-res1 &amp; deploy-c-res2 --&gt; deploy-c-gate-in\n        deploy-c-gate-internal --&gt; deploy-c-res1 &amp; deploy-c-res2\n        deploy-c-res3 --&gt; deploy-c-gate-internal\n        deploy-c-gate-out -----&gt; deploy-c-res4\n        deploy-c-gate-out --&gt; deploy-c-res3\n\n        class deploy-c-gate-in wave3;\n        class deploy-c-res4 wave3;\n\n        class deploy-c-res1 wave4;\n        class deploy-c-res2 wave4;\n        class deploy-c-gate-internal wave4;\n\n        class deploy-c-res3 wave5;\n        class deploy-c-gate-out wave5;\n    end\n\n    other[\"Other\"] --&gt; deploy-c-gate-out\n\n    class other wave5;</code></pre>"},{"location":"#synergy","title":"Synergy","text":"<p>As of now, the only known synergy is with ArgoCD.</p> <ul> <li>ArgoCD: same thing with Hook or SyncWaves. SyncWaves allows a gate to \"pause\" the deployment in the middle.</li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#deployment-waiter","title":"Deployment waiter","text":"<p>This will open if the deployment has the Available condition set to true.</p> <pre><code>apiVersion: gate.sh/v1alpha1\nkind: Gate\nmetadata:\n  name: wait-for-a-deployment\nspec:\n  targets:\n    - name: MyDeployment\n      selector:\n        apiVersion: apps/v1\n        kind: Deployment\n        name: my-deployment\n      validators:\n        - matchCondition:\n            type: Available\n</code></pre>"},{"location":"examples/#gate-waiter","title":"Gate waiter","text":"<p>This will open if other gates with the given labels are opened. This is useful to abstract workloads away.</p> <pre><code>apiVersion: gate.sh/v1alpha1\nkind: Gate\nmetadata:\n  name: wait-for-other-gates\nspec:\n  targets:\n    - name: Gates\n      selector:\n        apiVersion: gate.sh/v1alpha1\n        kind: Gate\n        labelSelector:\n          matchLabels:\n            deployment-stage: stage-x\n      validators:\n        - atLeast:\n            count: 3\n        - matchCondition:\n            type: Opened\n</code></pre>"},{"location":"examples/#argocd-application-waiter","title":"ArgoCD Application waiter","text":"<p>This gate will open if the argocd application <code>status.health.status</code> is set to <code>Healthy</code></p> <pre><code>apiVersion: gate.sh/v1alpha1\nkind: Gate\nmetadata:\n  name: wait-for-other-gates\nspec:\n  targets:\n    - name: Application\n      selector:\n        apiVersion: argoproj.io/v1alpha1\n        kind: Application\n        name: my-app\n        namespace: gitops\n      validators:\n        - jsonPointer:\n            pointer: /status/health/status\n            value: Healthy\n</code></pre>"},{"location":"get-started/","title":"Get started","text":""},{"location":"get-started/#installation","title":"Installation","text":""},{"location":"get-started/#prerequisite","title":"Prerequisite","text":"<p>You'll need to have a valid installation of Cert-Manager.</p>"},{"location":"get-started/#using-the-yaml-installer","title":"Using the YAML installer","text":"<p>Run the following command: </p> <pre><code>kubectl apply -f https://github.com/robinlioret/gate-operator/releases/download/v0.0.9/install.yaml\n</code></pre>"},{"location":"get-started/#using-the-helm-chart","title":"Using the Helm chart","text":"<pre><code>helm upgrade --install gate-operator oci://ghcr.io/robinlioret/gate-operator/gate-operator:0.0.5\n</code></pre> <p>Possible values can be found here: https://github.com/robinlioret/gate-operator/blob/main/dist/chart/values.yaml</p>"},{"location":"get-started/#create-your-first-gate","title":"Create your first gate","text":"<pre><code>cat &lt;&lt; EOF | kubectl apply -f -\napiVersion: gate.sh/v1alpha1\nkind: Gate\nmetadata:\n  name: gate-test\nspec:\n  targets:\n    - name: KubeProxy\n      selector:\n        apiVersion: apps/v1\n        kind: DaemonSet\n        name: kube-proxy\n        namespace: kube-system\nEOF\n</code></pre> <p>This gate should open if kube-proxy is deployed in the namespace kube-system.</p> <pre><code>kubectl get gates -A\n</code></pre> <p>Should display : <pre><code>NAMESPACE   NAME        STATE\ndefault     gate-test   Opened\n</code></pre></p>"},{"location":"get-started/#reading-information-on-your-gates","title":"Reading information on your gates","text":"<p>You can get information on you gate with the following command</p> <pre><code>kubectl get gate gate-test -o yaml\n</code></pre> <pre><code>apiVersion: gate.sh/v1alpha1\nkind: Gate\nmetadata:\n  name: gate-test\n  namespace: default\n  # ...\nspec:\n  # ...\nstatus:\n  # Condition of the gate for programmatic access\n  conditions:\n  - lastTransitionTime: \"2025-10-31T08:40:26Z\"\n    message: Gate was evaluated to true\n    reason: GateConditionMet\n    status: \"True\"\n    type: Opened\n  - lastTransitionTime: \"2025-10-31T08:40:26Z\"\n    message: Gate was evaluated to true\n    reason: GateConditionMet\n    status: \"False\"\n    type: Closed\n\n  # Next time the gate will be evaluated\n  nextEvaluation: \"2025-10-31T08:51:32Z\"\n\n  # Quick information of the gate status (Opened or Closed)\n  state: Opened\n\n  # Information on each target specified. Can help for troubleshooting.\n  # The condition's type field matches the name field on each target.\n  targetConditions:\n  - lastTransitionTime: \"2025-10-31T08:50:32Z\"\n    message: |\n      1 object(s) found\n      1 object match the validators\n      1/1 valid objects\n    reason: ObjectsFound\n    status: \"True\"\n    type: KubeProxy\n</code></pre>"},{"location":"get-started/#argocd-configuration","title":"ArgoCD configuration","text":"<p>You need to add the following snippet to your argocd cm</p> <pre><code>resource.customizations:\n  \"gate.sh/*\":\n      health.lua: |\n        hs = {}\n        if obj.status ~= nil then\n          if obj.status.conditions ~= nil then\n            for i, condition in ipairs(obj.status.conditions) do\n              if condition.type == \"Opened\" and condition.status == \"True\" then\n                hs.status = \"Healthy\"\n                hs.message = condition.message\n                return hs\n              end\n            end\n          end\n        end\n        hs.status = \"Progressing\"\n        hs.message = \"Waiting for the gate to open\"\n        return hs\n</code></pre> <p>This customizes the healthcheck for the gates, allowing ArgoCD to consider gates Healthy if opened or Progressing if closed.</p>"},{"location":"patterns/","title":"Patterns","text":""},{"location":"patterns/#context-example","title":"Context example","text":"<p>On the front page, we talked about the AWS LoadBalancerController needed to be deployed before the services of type LoadBalancer on an EKS cluster. If the order is not respected, the legacy LoadBalancer controller will take over and create Load Balancer that won't use the right annotations, ending up with a misconfigured load balancer.</p>"},{"location":"patterns/#front-gate-pattern","title":"Front Gate pattern","text":"<p>We only need one gate to deploy in the same Chart or ArgoCD application with the right annotations.</p> <p>The gate is coming in front of the deployment (by order):</p> <pre><code>flowchart LR\n    subgraph lbc[AWS LBC]\n        lbc-mhook[Mutating Webhook]\n        lbc-vhook[Validation Webhook]\n        lbc-deploy[Deployment]\n    end\n\n    subgraph ing1[Ingress Controller Public]\n        ing1-gate((Gate))\n        ing1-deploy[Deployment]\n        ing1-svc[Service]\n        ing1-other[...]\n        ing1-deploy &amp; ing1-svc &amp; ing1-other --&gt; ing1-gate\n    end\n\n    subgraph ing2[Ingress Controller Private]\n        ing2-gate((Gate))\n        ing2-deploy[Deployment]\n        ing2-svc[Service]\n        ing2-other[...]\n        ing2-deploy &amp; ing2-svc &amp; ing2-other  --&gt; ing2-gate\n    end\n\n    ing1-gate --&gt; lbc-mhook &amp; lbc-vhook &amp; lbc-deploy\n    ing2-gate --&gt; lbc-mhook &amp; lbc-vhook &amp; lbc-deploy</code></pre> <p>This is a naive approach since it quickly causes a lot of duplicated configuration. Here is an example for one gate</p> <pre><code>apiVersion: gate.sh/v1alpha1\nkind: Gate\nmetadata:\n  name: wait-for-aws-lbc\n  namespace: my-app-namespace\n  annotations:\n    # For ArgoCD\n    argocd.argoproj.io/hook: PreSync\n    argocd.argoproj.io/hook-delete-policy: HookSucceeded\nspec:\n  targets:\n    - selector:\n        apiVersion: admissionregistration.k8s.io/v1\n        kind: MutatingWebhookConfiguration\n        name: aws-load-balancer-webhook\n\n    - selector:\n        apiVersion: admissionregistration.k8s.io/v1\n        kind: ValidatingWebhookConfiguration\n        name: aws-load-balancer-webhook\n\n    - selector:\n        apiVersion: apps/v1\n        kind: Deployment\n        name: aws-load-balancer-controller\n        namespace: aws-load-balancer-controller\n      validators:\n        - matchCondition:\n            type: Available\n            status: !!str True\n</code></pre>"},{"location":"patterns/#facade-gate-pattern","title":"Facade Gate pattern","text":"<p>This pattern works with the previous one, by creating a gate that opens only if the main resources of the app are deployed. When this gate opens, the app is up. Other gates can detect it with a single reference.</p> <p>Per example:</p> <pre><code>flowchart LR\n    subgraph lbc[AWS LBC]\n        lbc-mhook[Mutating Webhook]\n        lbc-vhook[Validation Webhook]\n        lbc-deploy[Deployment]\n        lbc-gate((Gate))\n        lbc-gate --&gt; lbc-mhook &amp; lbc-deploy &amp; lbc-vhook\n    end\n\n    subgraph ing1[Ingress Controller Public]\n        ing1-gate((Gate))\n        ing1-deploy[Deployment]\n        ing1-svc[Service]\n        ing1-other[...]\n        ing1-deploy &amp; ing1-svc &amp; ing1-other --&gt; ing1-gate\n    end\n\n    subgraph ing2[Ingress Controller Private]\n        ing2-gate((Gate))\n        ing2-deploy[Deployment]\n        ing2-svc[Service]\n        ing2-other[...]\n        ing2-deploy &amp; ing2-svc &amp; ing2-other  --&gt; ing2-gate\n    end\n\n    ing1-gate --&gt; lbc-gate\n    ing2-gate --&gt; lbc-gate</code></pre> <p>By adding a gate behind the app deployment (here the load balancer controller), we create an abstraction for other gate to select.</p> <p>Here is a example for the AWS Load Balancer Controller gate:</p> <pre><code>apiVersion: gate.sh/v1alpha1\n# Here we use a ClusterGate since it's easier to refer and we have only one deployment of the LBC.\nkind: ClusterGate\nmetadata:\n  name: aws-lbc-ready\n  annotations:\n    # For ArgoCD\n    argocd.argoproj.io/hook: PostSync\nspec:\n  targets:\n    - selector:\n        apiVersion: admissionregistration.k8s.io/v1\n        kind: MutatingWebhookConfiguration\n        name: aws-load-balancer-webhook\n\n    - selector:\n        apiVersion: admissionregistration.k8s.io/v1\n        kind: ValidatingWebhookConfiguration\n        name: aws-load-balancer-webhook\n\n    - selector:\n        apiVersion: apps/v1\n        kind: Deployment\n        name: aws-load-balancer-controller\n        namespace: aws-load-balancer-controller\n      validators:\n        - matchCondition:\n            type: Available\n            status: !!str True\n</code></pre> <p>Then, in ingress controller deployments, we can have a gate like this :</p> <pre><code>apiVersion: gate.sh/v1alpha1\nkind: Gate\nmetadata:\n  name: wait-for-aws-lbc\n  namespace: my-app-namespace\n  annotations:\n    # For ArgoCD\n    argocd.argoproj.io/hook: PreSync\n    argocd.argoproj.io/hook-delete-policy: HookSucceeded\nspec:\n  targets:\n    - selector:\n        apiVersion: gate.sh/v1/alpha1\n        kind: ClusterGate\n        name: aws-lbc-ready\n      validators:\n        - matchCondition:\n            type: Opened\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>The Gate and ClusterGate CRD share the exact same reference and are interchangeable.</p> <pre><code>apiVersion: gate.sh/v1alpha1\nkind: Gate # or ClusterGate\nmetadata:\n  # ...\nspec:\n  # Targets are rules to fulfill to open the gate.\n  # A gate must have at least one target.\n  targets:\n      # (Optional) Default to Target{index}\n      # Name of the target, used to define target condition Type field\n    - name: ATargetName \n      # (Required) Rules used to find resource to evaluate\n      selector:\n        # (Required) Api Version of the resource\n        apiVersion: apps/v1\n        # (Required) Kind of object to look for\n        kind: Deployment\n        # (Optional) Namespace of the object.\n        # By default, and if it's relevant, the gate looks for resources inside its own namespace\n        namespace: my-namespace\n        # (Optional and mutually exclusive with labelSelector)\n        # Name of the resource.\n        name: my-deployment\n        # (Optional and mutually exclusive with name)\n        # Specification of a label selector\n        labelSelector:\n          matchLabels: {}\n          matchExpression: {}\n      # (Optional) Instruction on how to evaluate the target\n      # By default, the gate will open if at least one resource was found regardless of its state\n      # Validators are \"anded\" together (see \u00a7Behavious and patterns of validators)\n      validators:\n        # (Optional) Minimal amount of valid objects to validate the target. By default, it a minimum of 1.\n        - atLeast:\n            # (Optional) At least N objects must validate all the given conditions\n            count: 1\n            # (Optional) At least X percent of the found object must validate the other validators (if there are ones)\n            percent: 50\n        # (Optional) Check if the object has the right condition in its status.conditions\n        - matchCondition:\n            # (Required) Condition type in CamelCase\n            # Literally the type field of the condition to look for\n            type: Ready\n            # (Optional) default to \"True\" (with quotes, it's a string)\n            # The value of the condition \"True\", or \"False\"\n            status: \"True\"\n        # (Optional) Check if the field designed by the json pointer matches the given value\n        - jsonPointer:\n            # (Required) The JSON pointer (see https://gregsdennis.github.io/Manatee.Json/usage/pointer.html)\n            pointer: /status/state\n            # (Required) Value the JSON pointer must have to validate the validator\n            value: Opened\n  # (Optional) Operation to perform to reduce the targets to a single boolean\n  # By default, the targets are \"anded\"\n  operation:\n    # (Required) The operation's name\n    # Must be And or Or\n    operator: And\n  # (Optional) Default to 1 minutes (1m0s)\n  # Delay between two evaluations when the gate is opened\n  # WARNING: subject to change\n  evaluationPeriod: 53s\n  # (Optional) Consolidation when looking for opening the gate\n  consolidation:\n    # (Optional) Number of consecutive valid evaluation to consider the gate opened. Default to 1\n    count: 3\n    # (Optional) Delay between two evaluation when the gate is closed. Default to 10s.\n    delay: 5s\n# (Managed) status field with the computed resources on the gate\nstatus:\n  # Quick representation of the gate's status\n  # Used by the print feature\n  state: Opened # or Closed\n  # Kubernetes' conditions of the gate\n  conditions: # ...\n  # Result of the target computation\n  # Here can be found useful information for troubleshoot purposes\n  targetConditions:\n    - type: ATargetName # From the name of the represented target\n      status: \"False\"   # Condition status\n      reason: \"ConditionNotMet\"\n      message: |\n        [my-namespace/my-deployment] condition Ready is not True\n        1 object(s) found\n        0 object(s) validated\n        0/1 valid object(s)\n      # ...\n</code></pre>"},{"location":"reference/#behaviour-and-patterns-of-validators","title":"Behaviour and patterns of validators","text":"<p>There are three scenarios regarding the atLeast validator.</p> <ol> <li>One validator and it is atLeast</li> </ol> <p>The gate will open if at least N objects were selected regardless of their state</p> <ol> <li>One or more validator(s) but no atLeast validator</li> </ol> <p>The gate will open if at least 1 object was found and all the objects validate the validators.</p> <p>Per example: all the pod matching the label \"app\" = \"my-app\" has a Ready condition to true. The minimum at 1 protects against \"false opening\" when resources are not yet deployed.</p> <ol> <li>Two or more validator(s) with atLeast</li> </ol> <p>The gate will open if atLeast N (or X%) objects fulfill the other validators.</p>"}]}